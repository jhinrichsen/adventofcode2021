image:https://godoc.org/gitlab.com/jhinrichsen/adventofcode2021?status.svg["godoc",
link="https://godoc.org/gitlab.com/jhinrichsen/adventofcode2021"]
image:https://goreportcard.com/badge/gitlab.com/jhinrichsen/adventofcode2021["Go report
card", link="https://goreportcard.com/report/gitlab.com/jhinrichsen/adventofcode2021"]
image:https://gitlab.com/jhinrichsen/adventofcode2021/badges/main/pipeline.svg[link="https://gitlab.com/jhinrichsen/adventofcode2021/-/commits/main",title="pipeline status"]
image:https://gitlab.com/jhinrichsen/adventofcode2021/badges/main/coverage.svg[link="https://gitlab.com/jhinrichsen/adventofcode2021/-/commits/main",title="coverage report"]

= Advent of Code 2021

[index]
== Index

My take on https://adventofcode.com/2021/ in Go. As usual, i don't particularly
care if i provide my solutions _fast_, i try to be _correct_ on the first
answer, and care for being runtime efficient.
All puzzles are backed by unit testing the examples, and by some benchmarks.

Expected results are hard coded into the unit tests, so unless you are peeking
for a solution avoid looking at those.

|===
| Day | Number of tries for part 1 | Number of tries for part 2

| 1  | 1 | 1
| 2  | 1 | 1
| 3  | 1 | 1
| 4  | 1 | *2*
| 5  | 1 | 1
| 6  | 1 | 1
| 7  | 1 | 1
| 8  | 1 | TODO
| 9  | 1 | TODO
| 10 | 1 | 1
| 11 | 1 | 1
| 12 | 1 | 1
| 13 |  |
| 14 |  |
| 15 |  |
| 16 |  |
| 17 |  |
| 18 |  |
| 19 |  |
| 20 | 1 | 1 <1>
| 21 |  |
| 22 |  |
| 23 |  |
| 24 |  |
| 25 |  |
|===
<1> This one is picked because it is said to be a very good case for GPU optimization


---- --------Part 1---------   --------Part 2---------
Day       Time    Rank  Score       Time    Rank  Score
 10   15:36:53   39284      0   16:15:45   37919      0
  9   00:42:38    8385      0          -       -      -
  8   00:28:54    7835      0          -       -      -
  7   00:16:00    6872      0   00:23:18    5947      0
  6   00:22:46    7219      0   00:42:14    5105      0
  5   00:36:31    5008      0   01:30:41    7233      0
  4   13:46:10   40167      0   15:28:20   39605      0 <1>
  3       >24h   92810      0       >24h   70078      0
  2       >24h  118229      0       >24h  114094      0
  1       >24h  142010      0       >24h  128905      0
----
<1> I started on the weekend following Dec 1

== Day 1: Sonar Sweep

Nice and easy one. Parsing numbers happens so often i extended my helper file
`input.go` with an additional function that directly returns an array of
integers.

Benchmark:

----
go test -bench=. -run="" -benchmem
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay01Part2-8   	 1204111	      1033 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	gitlab.com/jhinrichsen/adventofcode2021	1.673s
----

To put 1.33 ns/op in perspective: without I/O, meaning excluding time for
reading puzzle input, the time it takes to solve part #1 is 1 μs.
Or, put the other way around, it solves part #1 one million times per second.

Go 1.17 introduces the use of register calling, but as most of my solutions are
in one function this is not a real difference to previous Go releases.

[source,go,linenums]
----
package adventofcode2021

func Day01Part1(ns []int) int {
	count := 0
	for i := 1; i < len(ns); i++ {
		if ns[i] > ns[i-1] {
			count++
		}
	}
	return count
}
----

Let's double check how this transfers to assembler.
Remember Go has its own assembler opcodes.
Even if you can recite chapter 'Conditional Jump' on page 64 of
https://www.amd.com/system/files/TechDocs/24592.pdf[AMD64 Reference] woken up at
3:30am in the middle of the night completely drunk, you will not find JLS.
For the time being, one needs to refer to Go internal source code to find the
mappings for
https://go.googlesource.com/go/+/master/src/cmd/asm/internal/arch/arch.go#145[
JLS]:

[source,go]
----
	instructions["JLS"] = x86.AJLS  /* lower or same (unsigned) (CF = 1 || ZF = 1) */
----

The https://go.dev/doc/asm[Quick Guide to Go's assembler] is a useful read to
understand this snippet.

[source,assembler]
----
"".Day01Part1 STEXT nosplit size=46 args=0x18 locals=0x0 funcid=0x0
	0x0000 00000 (day01.go:3)	TEXT	"".Day01Part1(SB), NOSPLIT|ABIInternal, $0-24
	0x0000 00000 (day01.go:3)	MOVQ	AX, "".ns+8(FP)
	0x0005 00005 (day01.go:3)	FUNCDATA	$0, gclocals·1a65e721a2ccc325b382662e7ffee780(SB)
	0x0005 00005 (day01.go:3)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x0005 00005 (day01.go:3)	FUNCDATA	$5, "".Day01Part1.arginfo1(SB)
	0x0005 00005 (day01.go:6)	MOVL	$1, CX            ; i := 1
	0x000a 00010 (day01.go:6)	XORL	DX, DX            ; count := 0
	0x000c 00012 (day01.go:5)	JMP	37
	0x000e 00014 (day01.go:6)	MOVQ	(AX)(CX*8), SI    ; ns[i] <1>
	0x0012 00018 (day01.go:6)	MOVQ	-8(AX)(CX*8), DI  ; ns[i-1] <1>
	0x0017 00023 (day01.go:7)	LEAQ	1(DX), R8
	0x001b 00027 (day01.go:6)	CMPQ	DI, SI
	0x001e 00030 (day01.go:7)	CMOVQLT	R8, DX
	0x0022 00034 (day01.go:5)	INCQ	CX                ; i++
	0x0025 00037 (day01.go:5)	CMPQ	BX, CX            ; len(ns) > i <2>
	0x0028 00040 (day01.go:5)	JGT	14
	0x002a 00042 (day01.go:10)	MOVQ	DX, AX            ; return count <3>
	0x002d 00045 (day01.go:10)	RET
----
<1> The index loop is easy enough for the compiler to reason it needs no bounds
checking, no panic()
<2> 3 words calling convention for slices: AX is pointer to
slice, BX is `len()`,
CX is `cap()`. `cap()` is not used in this function, so the compiler uses CX for
index `i`.
<3> return result via register, no stack cleanup required

== Day 2: Dive!

== Day 3: Binary Diagnostic

No brainer. The only noticable piece is maybe the use of closures to avoid deep
structures surrounded by an `if/else`:

----
    if part1 {
        // 10 lines of complicated business logic
	// including more indent levels
    } else {
        // 15 lines of complicated business logic
	// including more indent levels
    }
----

can be replaced using closures (anonymous inner functions)

----
    if part1 {
        fn1()
    } else {
        fn2()
    }
----

which is easier on the eyes.

== Day 4: Giant Squid

Part 1 Blattschuss.

Part2: one miss. My index was working when cutting input file into boards for
example input, but it was wrong and created 120 boards (the last 20 being empty)
instead of 100 boards when used on the read puzzle input for part 2.


Another gotcha: dynamically resizing a slice in a struct does not work, even
when passed via pointer receiver.

----
type S struct {
	A []int
}

func (a *S) add(i int) {
	a.A = append(a.A, i) // does not work
}
----

Benchmark for part 2:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay04Part2-8   	     687	   1852821 ns/op	  560245 B/op	    2846 allocs/op
----

1.8 ms, excluding I/O, including parsing.

== Day 5: Hydrothermal Venture

Took me 30 min for part 1 and then another 60 min for part 2. The implementation
transparently handles both part 1 and part 2 using

----
diagonal := func(c1, c2 complex128) bool {
        return real(c1) != real(c2) && imag(c1) != imag(c2)
}
----

----
// for part 1, only consider horizontal or vertical lines
if part1 && diagonal(src, dst) {
        continue
}
----

Benchmark:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay05Part2-8   	      22	  46896856 ns/op	16126620 B/op	    7643 allocs/op
----

That is 46 ms for part 2, excluding I/O, including parsing, for 500 lines and a
total of 203660 coordinates, averaging to 230 ns per coordinate. 230*10^-9.

Using integer based arithmetic instead of complex numbers is a little bit
faster, it completes at 87% of the time the complex implementation requires.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay05Part2-8   	      26	  40890804 ns/op	16117340 B/op	    7627 allocs/op
----

== Day 6: Lanternfish

Part 2 blows my machine around day 240/245 of 256 days when using the naive
approach of counting each lanternfish separate.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay06Part2-8   	   60168	     19808 ns/op	    5880 B/op	       8 allocs/op
----

20 μs, this time including I/O and parsing, or 50_000 solutions per second.

There is one superfluous bound check at runtime, an array of lines is passed
although we only expect one single line of comma separated values:

[source,go]
----
21 func Day06(lines []string, days int) (uint, error) {
22         fishes, err := ParseCommaSeparatedNumbers(lines[0]) <1>
----
<1> directly accessing line #0 requires bounds checking

----
"".Day06 STEXT size=350 args=0x20 locals=0x60 funcid=0x0
	0x0000 00000 (day06.go:21)	TEXT	"".Day06(SB), ABIInternal, $96-32
	0x0000 00000 (day06.go:21)	CMPQ	SP, 16(R14)
	0x0004 00004 (day06.go:21)	PCDATA	$0, $-2
	0x0004 00004 (day06.go:21)	JLS	296
	0x000a 00010 (day06.go:21)	PCDATA	$0, $-1
	0x000a 00010 (day06.go:21)	SUBQ	$96, SP
	0x000e 00014 (day06.go:21)	MOVQ	BP, 88(SP)
	0x0013 00019 (day06.go:21)	LEAQ	88(SP), BP
	0x0018 00024 (day06.go:21)	MOVQ	AX, "".lines+104(FP)
	0x001d 00029 (day06.go:21)	FUNCDATA	$0, gclocals·1a65e721a2ccc325b382662e7ffee780(SB)
	0x001d 00029 (day06.go:21)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x001d 00029 (day06.go:21)	FUNCDATA	$5, "".Day06.arginfo1(SB)
	0x001d 00029 (day06.go:21)	NOP
	0x0020 00032 (day06.go:22)	TESTQ	BX, BX <1>
	0x0023 00035 (day06.go:22)	JLS	285 <2>


	0x011d 00285 (day06.go:22)	XORL	AX, AX
	0x011f 00287 (day06.go:22)	MOVQ	BX, CX
	0x0122 00290 (day06.go:22)	CALL	runtime.panicIndex(SB)
----
<1> lines passed via AX, len(lines) passed via BX
<2> JLS translates to JBE, 'Jump if below or equal' (BX <= 0)

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay06Part2-8   	   60613	     19137 ns/op	    7552 B/op	       2 allocs/op
----

If we expect exactly one line, it should be part of the function's signature.
This is not a premature optimization, it is part of the contract.

In addition, if the algorithm requires a list of numbers, it should be stated
so. Parsing from a comma separated list of string values is duty of the caller.
Of course we provide `ParseCommaSeparatedNumbers()` for this exact use case.

[source,go]
----
func Day06(fishes []int, days uint) (uint, error) {
----

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay06Part2-8   	 1006672	      1076 ns/op	       0 B/op	       0 allocs/op
----

So instead of 20 μs, we are down to 1 μs, and reduced 8 allocations to 0.

Ready for some ARM Opcodes? Let's Go...

.Disassembler listing
|===
| Assembler | Go

a|
----
0x0000 00000 (day06.go:21)	TEXT	"".Day06(SB), ABIInternal, $112-56
0x0000 00000 (day06.go:21)	MOVD	16(g), R1
0x0004 00004 (day06.go:21)	PCDATA	$0, $-2
0x0004 00004 (day06.go:21)	MOVD	RSP, R2
0x0008 00008 (day06.go:21)	CMP	R1, R2
0x000c 00012 (day06.go:21)	BLS	268
0x0010 00016 (day06.go:21)	PCDATA	$0, $-1
0x0010 00016 (day06.go:21)	MOVD.W	R30, -112(RSP)
0x0014 00020 (day06.go:21)	MOVD	R29, -8(RSP)
0x0018 00024 (day06.go:21)	SUB	$8, RSP, R29
0x001c 00028 (day06.go:21)	FUNCDATA	ZR, gclocals·564c88c798e834d77927d2fafb0b5dca(SB)
0x001c 00028 (day06.go:21)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
0x001c 00028 (day06.go:21)	FUNCDATA	$5, "".Day06.arginfo1(SB)
----

a|
----
func Day06(fishes []int, days int) (uint, error) {
----
a|
----
0x001c 00028 (day06.go:23)	STP	(ZR, ZR), "".ages-72(SP)
0x0020 00032 (day06.go:23)	STP	(ZR, ZR), "".ages-56(SP)
0x0024 00036 (day06.go:23)	STP	(ZR, ZR), "".ages-40(SP)
0x0028 00040 (day06.go:23)	STP	(ZR, ZR), "".ages-24(SP)
0x002c 00044 (day06.go:23)	MOVD	ZR, "".ages-8(SP)
----

a|
----
var ages [groups]uint
----
a|
----
0x0030 00048 (day06.go:24)	MOVD	"".fishes+8(FP), R2
0x0034 00052 (day06.go:24)	MOVD	"".fishes(FP), R3
0x0038 00056 (day06.go:24)	MOVD	ZR, R0
0x003c 00060 (day06.go:24)	JMP	84
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x0040 00064 (day06.go:25)	MOVD	$"".ages-72(SP), R5
0x0044 00068 (day06.go:25)	MOVD	(R5)(R4<<3), R6
0x0048 00072 (day06.go:25)	ADD	$1, R6, R6
0x004c 00076 (day06.go:25)	MOVD	R6, (R5)(R4<<3)
----

a|
----
ages[fishes[i]]++
----
a|
----
0x0050 00080 (day06.go:24)	ADD	$1, R0, R0
0x0054 00084 (day06.go:24)	CMP	R0, R2
0x0058 00088 (day06.go:24)	BLE	108
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x005c 00092 (day06.go:25)	MOVD	(R3)(R0<<3), R4
0x0060 00096 (day06.go:25)	CMP	$9, R4
0x0064 00100 (day06.go:25)	BLO	64
0x0068 00104 (day06.go:25)	JMP	252
----

a|
----
ages[fishes[i]]++
----
a|
----
0x006c 00108 (day06.go:24)	MOVD	"".days+24(FP), R0
0x0070 00112 (day06.go:24)	MOVD	ZR, R1
0x0074 00116 (day06.go:24)	JMP	140
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x0078 00120 (day06.go:33)	MOVD	"".ages-24(SP), R3
0x007c 00124 (day06.go:33)	ADD	R2, R3, R3
0x0080 00128 (day06.go:33)	MOVD	R3, "".ages-24(SP)
----

a|
----
ages[6] += babies
----
a|
----
0x0084 00132 (day06.go:34)	MOVD	R2, "".ages-8(SP)
----

a|
----
ages[8] = babies
----
a|
----
0x0088 00136 (day06.go:28)	ADD	$1, R1, R1
0x008c 00140 (day06.go:28)	CMP	R1, R0
0x0090 00144 (day06.go:28)	BLE	160
----

a|
----
for day := 0; day < days; day++ {
----
a|
----
0x0094 00148 (day06.go:29)	MOVD	"".ages-72(SP), R2
0x0098 00152 (day06.go:29)	MOVD	ZR, R3
----

a|
----
babies := ages[0]
----
a|
----
0x009c 00156 (day06.go:30)	JMP	240
0x00a0 00160 (day06.go:30)	MOVD	ZR, R0
0x00a4 00164 (day06.go:30)	MOVD	ZR, R1
----

a|
----
for age := 0; age < groups-1; age++ {
----
a|
----
0x00a8 00168 (day06.go:28)	JMP	192
----

a|
----
for day := 0; day < days; day++ {
----
a|
----
0x00ac 00172 (day06.go:38)	ADD	$1, R0, R2
----

a|
----
for i := range ages {
----
a|
----
0x00b0 00176 (day06.go:39)	MOVD	$"".ages-72(SP), R3
0x00b4 00180 (day06.go:39)	MOVD	(R3)(R0<<3), R3
0x00b8 00184 (day06.go:39)	ADD	R3, R1, R1
----

a|
----
sum += ages[i]
----
a|
----
0x00bc 00188 (day06.go:38)	MOVD	R2, R0
0x00c0 00192 (day06.go:38)	CMP	$9, R0
0x00c4 00196 (day06.go:38)	BLT	172
----

a|
----
for i := range ages {
----
a|
----
0x00c8 00200 (day06.go:41)	MOVD	R1, "".~r2+32(FP)
0x00cc 00204 (day06.go:41)	STP	(ZR, ZR), "".~r3+40(FP)
0x00d0 00208 (day06.go:41)	MOVD	-8(RSP), R29
0x00d4 00212 (day06.go:41)	MOVD.P	112(RSP), R30
0x00d8 00216 (day06.go:41)	RET	(R30)
----

a|
----
return sum, nil
----
a|
----
0x00dc 00220 (day06.go:31)	ADD	$1, R3, R4
0x00e0 00224 (day06.go:31)	MOVD	$"".ages-72(SP), R5
0x00e4 00228 (day06.go:31)	MOVD	(R5)(R4<<3), R6
0x00e8 00232 (day06.go:31)	MOVD	R6, (R5)(R3<<3)
----

a|
----
ages[age] = ages[age+1]
----
a|
----
0x00ec 00236 (day06.go:30)	MOVD	R4, R3
0x00f0 00240 (day06.go:30)	CMP	$8, R3
0x00f4 00244 (day06.go:30)	BLT	220
0x00f8 00248 (day06.go:30)	JMP	120
----

a|
----
for age := 0; age < groups-1; age++ {
----
a|
----
0x00fc 00252 (day06.go:25)	MOVD	R4, R0
0x0100 00256 (day06.go:25)	MOVD	$9, R1
0x0104 00260 (day06.go:25)	PCDATA	$1, $1
0x0104 00260 (day06.go:25)	CALL	runtime.panicIndex(SB) <1>
0x0108 00264 (day06.go:25)	HINT	ZR
0x010c 00268 (day06.go:25)	NOP
----

a|
----
ages[fishes[i]]++
----
a|
----
0x010c 00268 (day06.go:21)	PCDATA	$1, $-1
0x010c 00268 (day06.go:21)	PCDATA	$0, $-2
0x010c 00268 (day06.go:21)	MOVD	R30, R3
0x0110 00272 (day06.go:21)	CALL	runtime.morestack_noctxt(SB)
0x0114 00276 (day06.go:21)	PCDATA	$0, $-1
0x0114 00276 (day06.go:21)	JMP	0
----

a|
----
func Day06(fishes []int, days int) (uint, error) {
----



|===
<1> No more bound checking on input

There is one more bound check in

    ages[fishes[i]]++

We are using the input itself to index into the `ages` array, which the compiler
obviously cannot verify.

Verification:

[source,go]
----
21 func Day06(fishes []int, days int) (uint, error) {
22         const groups = 8
23         var ages [groups + 1]uint // 0..7 plus babies in 8
24         for i := 0; i < len(fishes); i++ {
25                 ages[fishes[i]]++
26         }
----

Now, there's a shortcut for checking for bound checking.
Instead of looking at the disassembly, one can

----
go build -gcflags="-d=ssa/check_bce/debug=1" day06.go
./day06.go:25:7: Found IsInBounds
----

The message is a bit misleading for my taste, what the compiler is telling us is
that line #25 requires bound checking.

What if we provide some more information about our `fishes` universe?
We expect ages from 0..7, so what if we hint `ages[fishes[i] % groups]`?

[source,go]
----
21 func Day06(fishes []int, days int) (uint, error) {
22         const groups = 8
23         var ages [groups + 1]uint // 0..7 plus babies in 8
24         for i := 0; i < len(fishes); i++ {
25                 ages[fishes[i]%groups]++
26         }
----

----
go build -gcflags="-d=ssa/check_bce/debug=1" day06.go
./day06.go:25:7: Found IsInBounds
----

Nearly there, but still checking.
x % 8 does not necessarily result in `0..7`.
If x is of type `int`, it can be negative, and `-3 % 8 = -3`, so the compiler is
right to keep checking.
One more try, this time using `uint` instead of `int` fishes:

----
 21 func Day06(fishes []uint, days uint) (uint, error) {
 22         const groups = 8
 23         var ages [groups + 1]uint // 0..7 plus babies in 8
 24         for i := 0; i < len(fishes); i++ {
 25                 ages[fishes[i]%groups]++
 26         }
----

Great, no more bound checking.

.Disassembler listing
|===
| Assembler | Go

a|
----
0x0000 00000 (day06.go:21)	TEXT	"".Day06(SB), NOSPLIT|LEAF|ABIInternal, $96-56
0x0000 00000 (day06.go:21)	MOVD.W	R30, -96(RSP)
0x0004 00004 (day06.go:21)	MOVD	R29, -8(RSP)
0x0008 00008 (day06.go:21)	SUB	$8, RSP, R29
0x000c 00012 (day06.go:21)	FUNCDATA	ZR, gclocals·564c88c798e834d77927d2fafb0b5dca(SB)
0x000c 00012 (day06.go:21)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
0x000c 00012 (day06.go:21)	FUNCDATA	$5, "".Day06.arginfo1(SB)
----

a|
----
func Day06(fishes []uint, days uint) (uint, error) {
----
a|
----
0x000c 00012 (day06.go:23)	STP	(ZR, ZR), "".ages-72(SP)
0x0010 00016 (day06.go:23)	STP	(ZR, ZR), "".ages-56(SP)
0x0014 00020 (day06.go:23)	STP	(ZR, ZR), "".ages-40(SP)
0x0018 00024 (day06.go:23)	STP	(ZR, ZR), "".ages-24(SP)
0x001c 00028 (day06.go:23)	MOVD	ZR, "".ages-8(SP)
----

a|
----
var ages [groups + 1]uint // 0..7 plus babies in 8
----
a|
----
0x0020 00032 (day06.go:24)	MOVD	"".fishes+8(FP), R0
0x0024 00036 (day06.go:24)	MOVD	"".fishes(FP), R1
0x0028 00040 (day06.go:24)	MOVD	ZR, R2
0x002c 00044 (day06.go:24)	JMP	76
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x0030 00048 (day06.go:25)	MOVD	(R1)(R2<<3), R3
0x0034 00052 (day06.go:25)	UBFIZ	$3, R3, $3, R3
0x0038 00056 (day06.go:25)	MOVD	$"".ages-72(SP), R4
0x003c 00060 (day06.go:25)	MOVD	(R4)(R3), R5
0x0040 00064 (day06.go:25)	ADD	$1, R5, R5
0x0044 00068 (day06.go:25)	MOVD	R5, (R4)(R3)
----

a|
----
ages[fishes[i]%groups]++
----
a|
----
0x0048 00072 (day06.go:24)	ADD	$1, R2, R2
0x004c 00076 (day06.go:24)	CMP	R2, R0
0x0050 00080 (day06.go:24)	BGT	48
0x0054 00084 (day06.go:24)	MOVD	"".days+24(FP), R0
0x0058 00088 (day06.go:24)	MOVD	ZR, R1
0x005c 00092 (day06.go:24)	JMP	116
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x0060 00096 (day06.go:33)	MOVD	"".ages-24(SP), R3
0x0064 00100 (day06.go:33)	ADD	R2, R3, R3
0x0068 00104 (day06.go:33)	MOVD	R3, "".ages-24(SP)
----

a|
----
ages[6] += babies
----
a|
----
0x006c 00108 (day06.go:34)	MOVD	R2, "".ages-8(SP)
----

a|
----
ages[8] = babies
----
a|
----
0x0070 00112 (day06.go:28)	ADD	$1, R1, R1
0x0074 00116 (day06.go:28)	CMP	R1, R0
0x0078 00120 (day06.go:28)	BLS	136
----

a|
----
for day := uint(0); day < days; day++ {
----
a|
----
0x007c 00124 (day06.go:29)	MOVD	"".ages-72(SP), R2
0x0080 00128 (day06.go:29)	MOVD	ZR, R3
----

a|
----
babies := ages[0]
----
a|
----
0x0084 00132 (day06.go:30)	JMP	216
0x0088 00136 (day06.go:30)	MOVD	ZR, R0
0x008c 00140 (day06.go:30)	MOVD	ZR, R1
----

a|
----
for age := 0; age < groups; age++ {
----
a|
----
0x0090 00144 (day06.go:28)	JMP	168
----

a|
----
for day := uint(0); day < days; day++ {
----
a|
----
0x0094 00148 (day06.go:38)	ADD	$1, R0, R2
----

a|
----
for i := range ages {
----
a|
----
0x0098 00152 (day06.go:39)	MOVD	$"".ages-72(SP), R3
0x009c 00156 (day06.go:39)	MOVD	(R3)(R0<<3), R3
0x00a0 00160 (day06.go:39)	ADD	R3, R1, R1
----

a|
----
sum += ages[i]
----
a|
----
0x00a4 00164 (day06.go:38)	MOVD	R2, R0
0x00a8 00168 (day06.go:38)	CMP	$9, R0
0x00ac 00172 (day06.go:38)	BLT	148
----

a|
----
for i := range ages {
----
a|
----
0x00b0 00176 (day06.go:41)	MOVD	R1, "".~r2+32(FP)
0x00b4 00180 (day06.go:41)	STP	(ZR, ZR), "".~r3+40(FP)
0x00b8 00184 (day06.go:41)	ADD	$96, RSP
0x00bc 00188 (day06.go:41)	SUB	$8, RSP, R29
0x00c0 00192 (day06.go:41)	RET	(R30)
----

a|
----
return sum, nil
----
a|
----
0x00c4 00196 (day06.go:31)	ADD	$1, R3, R4
0x00c8 00200 (day06.go:31)	MOVD	$"".ages-72(SP), R5
0x00cc 00204 (day06.go:31)	MOVD	(R5)(R4<<3), R6
0x00d0 00208 (day06.go:31)	MOVD	R6, (R5)(R3<<3)
----

a|
----
ages[age] = ages[age+1]
----
a|
----
0x00d4 00212 (day06.go:30)	MOVD	R4, R3
0x00d8 00216 (day06.go:30)	CMP	$8, R3
0x00dc 00220 (day06.go:30)	BLT	196
0x00e0 00224 (day06.go:30)	JMP	96
----

a|
----
for age := 0; age < groups; age++ {
----

|===


NOTE: This will probably be the last AARCH64 disassembler, it _really_ is not meant for us humans.

== Day 7: The Treachery of Whales

== Day 8: Seven Segment Search

== Day 9: Smoke Basin

== Day 10: Syntax Scoring

== Day 11: Dumbo Octopus

== Day 12: Passage Pathing

== Day 13: Transparent Origami

Using Jetbrains' IDEA Ultimate in combination with Junie running Sonnet 4.
A major pain in the neck.
I ask for a review of the CONTRIBUTING.md document, and Junie starts refactoring day 11 test cases.
It always does WAY more than asked for, and acts like a young dog that chews your sofa and pisses on the carpet.
It needs constant corrections, repeated limits, my experience is really bad.

Like i ask it a question, but i get no answer.
image::assets/Screenshot From 2025-08-04 19-14-27.png[]

But in the end we have a unit tests for the example, and for part 1.
image::assets/Screenshot From 2025-08-04 20-09-30.png[]

=== Baseline

These generated sources are our baseline, they are available from this repository in `assets/junie-sonnet4/day13.go resp. day13_test.go.

=== An opinionated source code review created by Junie/ Sonnet4 by a senior Go programmer 

As a prerequisite, Junie was prompted to follow the rules set forth in CONTRIBUTING.md.
We can argue if performance should have such a high priority, but this is a given prerequisite.
If your financial controller tells you to cut down on deployments costs, no debates.

==== `day13.go`

----
// Point represents a coordinate on the transparent paper
type Point struct {
	X, Y int
}
----

This has vague similarity to Go's image.Point from the stdlib.

----
type Point struct {
	X, Y int
}
----

The struct is removed, and replaced with an import.

Next is a Fold struct
----
// Fold represents a fold instruction
type Fold struct {
	Axis  string // "x" or "y"
	Value int
}
----

which is used to hold the fold section in puzzle input

----
fold along x=655
fold along y=447
----

The axis representation as a `string`, well,

----
		if fold.Axis == "y" {
----

Given that 

- we have a 2D system, so the only instances are x and y
- the value is always positive

not very effective.
Instead, we represent the first axis (X) as positive numbers, and the second axis (Y) as negative numbers.

The section is another struct, 

----
type Day13Data struct {
	Dots     map[image.Point]bool
	Folds    []int
	DotCount int
}
----

Using `Data` as part of the name is kindof DRY, but ok, Day13 is already taken.
The struct carries the binary representation of the puzzle input from the Parser to the Solver.
`DotCount` is just `len(Dots)`.
This is both error prone, and superfluous, and unused.
Unused - the declaration and the one single initialization can safely be removed.
This leaves us with a struct holding two fields, in a language like Go that supports multiple return types not necessary.

From
----
day13.go:// Day13Data holds the parsed input for Day 13
day13.go:type Day13Data struct {
day13.go:func NewDay13(lines []string) Day13Data {
day13.go:func Day13(data Day13Data, part1 bool) uint {
----

we refactor to

----
day13.go:func NewDay13(lines []string) (map[image.Point]bool, []int) {
day13.go:func Day13(dotsIn map[image.Point]bool, folds []int, part1 bool) uint {
----

Dots are kept in a sparse map with value type `bool`, which is standard Go Set handling.
The one disadvantage lies in the interpretation of a map key that exists, but is set to false - is this a Point?
Good for triple logic, but not required here, so we refactor.

----
map[image.Point]bool     <1>
map[image.Point]struct{} <2>
----
<1> entry level
<2> expert level (zero allocation)

So far we have erased everything we came across - the best code is code that is not written.
Now, for the signature of the Parser, it does not return an `error` type.

----
func NewDay13(lines []string) (map[image.Point]struct{}, []int) {
----

which is unusual because even in our well behaved environment (we don't expect malign input) there's always someting going wrong.
The parsing logic is straightforward, using stdlib's `TrimSpace`, `Split`, `Atoi`, reading the two sections one after another, toggling on the interim empty line.
But it silently skips handling a couple of conditions that i would not dare to ignore.

----
if strings.HasPrefix(line "fold along ") {
    ...
} <1>

if len(parts) == 2 {
    ....
} <1>

value, _ := strconv.Atoi(...) <2> 
----
<1> no else condition
<2> ignore errors

Next in line is `Day13` solver, which looks pretty standard.
It creates a copy of the input map to avoid modifying original data.
One nice feature: when passing either one fold or many folds as a slice, `folds[:1`] is like `folds[0]` but a slice.

----
foldsToApply := folds
if part1 {
	// Part 1: only apply the first fold
	foldsToApply = folds[:1]
}

for _, fold := range foldsToApply {
	dots = applyFold(dots, fold)
}
---

I find this more concise:

----
for _, fold := range folds {
	dots = applyFold(dots, fold)
	// Part 1: only apply the first fold
	if part1 {
		break
	}
}
----

On to `applyFold`, again pretty standard.
Creates a copy of the input data to avoid modification.
Then checks for a `0` fold, which is very good, but has no error handling and silenty does nothing

----
if fold == 0 {
	return dots
}
----

This should rather be an error case in the parser, as it could be an indicator for an unintialized value.
The folding itself is just a new translated `image.Point`:

----
newPoint = image.Point{X: 2*line - point.X, Y: point.Y} <1>
newPoint = image.Point{X: point.X, Y: 2*line - point.Y} <2>
----
<1> X axis fold
<2> Y axis fold

==== `day13_test.go`

Junie created the required examples #1, example #2, and part 1 test cases, and also created the benchmark for part 1.
The one existing benchmark (for now) calls a `bench13` function, the three existing tests don't use this pattern.
The `bench13` function's correctly identifies as a test helper function:

----
func bench13(b *testing.B, part1 bool) {
	b.Helper()
----

Junie does not use range-over-int (since Go 1.22) although contributing rules clearly state to use Go's full feature set for the version in `go.mod`.

Junie did not locate the `exampleFilename()` utility function from `input.go` referenced in the contributing rules.
The test case for the first example uses the correct expected solution, `want := uint(17)` as described in the puzzle example.
The use of a dedicated variable including a type case is not useful, better use `const want = 17`.
The puzzle description then uses a second fold, but hints to focus on the first fold only and the expected 17.
Junie created a second fold and counted 16 points after the second fold.
Exhaustive, not required, but we all know this will be the upcoming part 2.

=== Optimization

==== P1: remove superfluous fluff (structs and the like)

This is our baseline

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
BenchmarkDay13Part1-16              6394            183056 ns/op          191393 B/op        943 allocs/op
PASS
ok      gitlab.com/jhinrichsen/adventofcode2021 1.193s
----

After refactoring, without any optimization, we get this:

----
              │  baseline   │               perf1                │
              │   sec/op    │   sec/op     vs base               │
Day13Part1-16   183.1µ ± 0%   167.2µ ± 2%  -8.67% (p=0.000 n=10)
----

We already shaved off 10% by just simplifying, not optimizing.
Memory consumption has decreased marginally.

==== P2: No stdlib in Parser

Removing the stdlib (`Strip`, `Trim`, `Split`, `Atoi`) from the Parser, and replacing it with an optimized parser for our use case (e.g. no parsing of negative number, no NaN, no -Inf):

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
              │     p1      │                 p2                 │
              │   sec/op    │   sec/op     vs base               │
Day13Part1-16   167.2µ ± 2%   136.1µ ± 2%  -18.62% (p=0.000 n=10)         <1>

              │      p1     │                  p2                │
              │     B/op    │     B/op      vs base              │
Day13Part1-16   186.4Ki ± 0%   158.6Ki ± 0%  -14.90% (p=0.000 n=10)       <2>

              │     p1      │                 p2                 │
              │  allocs/op  │ allocs/op   vs base                │
Day13Part1-16   943.00 ± 0%   54.00 ± 0%  -94.27% (p=0.000 n=10)          <3>
----
<1> Runtime down by 20%
<2> allocation size down by 15%
<3> number of allocations down by 95%

==== 3. 2D grid representation of points

Junie decided to keep Pointes in a sparse hashmap.
We are using image.Point, but the standard library offers no support for flipping images, and we don't want to introduce third party libraries that can do image flipping.
Using a 2D grid instead of a sparse Hashmap shows a steep decrease in performance:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
              │     p2      │                   p3                   │
              │   sec/op    │    sec/op     vs base                  │
Day13Part1-16   136.1µ ± 2%   1708.5µ ± 2%  +1155.76% (p=0.000 n=10)

              │      p2      │                  p3                    │
              │     B/op     │     B/op       vs base                 │
Day13Part1-16   158.6Ki ± 0%   2517.3Ki ± 0%  +1486.77% (p=0.000 n=10)

              │     p2     │                   p3                   │
              │ allocs/op  │  allocs/op    vs base                  │
Day13Part1-16   54.00 ± 0%   1792.00 ± 0%  +3218.52% (p=0.000 n=10)
----

==== 4. 1D representation

Go does not support 2D arrays, so creating a 2D array is creating a 1D y array and then N times creating 1D x arrays.
For our use case this can easily create thousands of array allocations.
As an alternative, we can create a 1D array of size width * height, and use linear access (`y * w + x`):

==== 5. Bitset representation

Using a bit as the underlying datatype, comparable to the bool value, but bool will be packed into a byte, and a bit
physically is one bit.

==== 6. Bit based calculations based on 64 bit words

This is as close as we get to the CPU, directly use the full 64 bits of a word in the CPU, including native bit operations.
The algorithm must take extra care of underused and overlapping bits in a word.

----

Time for a short wrapup:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 7 7840HS w/ Radeon 780M Graphics
              │   baseline   │                parser                │                   1D                    │                  bits                  │                words                │
              │    sec/op    │    sec/op     vs base                │    sec/op      vs base                  │    sec/op      vs base                 │   sec/op     vs base                │
Day13Part1-16   183.06µ ± 0%   136.06µ ± 2%  -25.68% (p=0.000 n=10)   1640.85µ ± 3%  +796.36% (p=0.000 n=10)   1694.78µ ± 1%  +825.83% (p=0.000 n=10)    51.44µ ± 2%  -71.90% (p=0.000 n=10)

              │   baseline   │                parser                │                   1D                    │                 bits                   │                words                │
              │     B/op     │     B/op      vs base                │     B/op       vs base                  │     B/op      vs base                  │     B/op      vs base               │
Day13Part1-16   186.9Ki ± 0%   158.6Ki ± 0%  -15.12% (p=0.000 n=10)   2320.3Ki ± 0%  +1141.39% (p=0.000 n=10)   304.2Ki ± 0%  +62.78% (p=0.000 n=10)      168.2Ki ± 0%  -9.98% (p=0.000 n=10)

              │   baseline   │               parser                 │                 1D                      │                bits                    │               words                 │
              │  allocs/op   │  allocs/op   vs base                 │ allocs/op   vs base                     │ allocs/op   vs base                    │ allocs/op   vs base                 │
Day13Part1-16    943.000 ± 0%   54.000 ± 0%  -94.27% (p=0.000 n=10)   4.000 ± 0%  -99.58% (p=0.000 n=10)        4.000 ± 0%  -99.58% (p=0.000 n=10)       3.000 ± 0%  -99.68% (p=0.000 n=10)
----

This shows very nicely the tradeoff betwenn perfect runtime and perfect memory consumption, pick one.
The sparse hashmap is fast but memory intensive, it creates 943 * 187 KiB for one operation, i.e. 170 MiB/op.
The optimized parser is slightly faster, it optimizes away some generalizations in string processing that do not exist in our use case.
The main advantage of the custom parser is it brings down memory consumption from 170 MiB/op down to 8 MiB/op.
Factor 20 means you can run your service on all working days for a complete month, instead of just one day.

The 1D representation is slower, it has no sparse points as in the hashmap, it needs to churn on the complete virtual grid.
One memory allocation increases drastically (a complete grid versus a sparse hashmap), but only 4 allocations are required, so memory consumption is 9 MiB/op.

When using bits instead of bool, we are really using one bit to represent a lit point.
Comparing 1D (bool) to 1D (bits), it shows the same characteristics except for the bytes/alloc.
We are now packing 8 bits into a byte, so the number of allocations is the same.
The bytes/op drops from 2320.3 KiB to 204.2 KiB, which is a factor of 7.36, very close to the number of bits we are packing into what we use for bool (8).

As the last alternative, we don't operate on dedicated bits, but use the full CPU length of 64 bit.
Runtime drops by a factor of 3.5, slight drop in bytes/op of 10%, and a massive drop in number of allocations from 943 to 3, factor 314.
These factors are cumulative, 3.5 times 314 is 1.100.
Duplicate this factor, because if GC kicks in we not only need to setup memory, we also need to tear down memory, so we end up with a factor of 2.200.
If the budget for running the baseline lasts for one day, the optimized version will run for 6 years.

== Day 14: Extended Polymerization

== Day 15: Chiton

== Day 16: Packet Decoder

== Day 17: Trick Shot

== Day 18: Snailfish

== Day 19: Beacon Scanner

Easiest puzzle so far, took me 23 min for both parts.
Everybody and their mother was fast on this one, so we broke the private
leaderboard :-).

Mysteriously, i had no off-by-one in this puzzle, and avoided my typical
mistakes:

----
	burn := func(dist int) int {
		if part1 {
			return dist
		}
		// OEIS A000217 triangular number
		return dist * (dist + 1) / 2 <1>
	}

	fuel := func(pos int) int {
		sum := 0
		for i := range positions {
			dist := positions[i] - pos
			if dist < 0 {
				dist = -dist <2>
			}
			sum += burn(dist)
		}
		return sum
	}

	fmin := math.MaxInt32 <3>
	for pos := min; pos <= max; pos++ { <4>
		f := fuel(pos)
		if f < fmin {
			fmin = f
		}
	}
----
<1> OEIS contains thousands of man-years of the smartest brains on this planet
ever
<2> A distance can never be negative
<3> Do not initialize min values to 0
<4> Control end of interval (pos < max versus pos <= max)

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay07Part2-8   	     260	   4508358 ns/op	       0 B/op	       0 allocs/op
----

4.5 ms, no allocations.

== Day 20: Trench Maps

== Day 21: Dirac Dice

== Day 22: Reactor Reboot

== Day 23: Amphipod

== Day 24: Arithmetic Logic Unit

== Day 25: Sea Cucumber

TODO: implement, and use as the best available showcase of all aoc puzzles for GPU rewrite.
Expect 20x to 50x better performance.
