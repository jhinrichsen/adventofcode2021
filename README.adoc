image:https://godoc.org/gitlab.com/jhinrichsen/adventofcode2021?status.svg["godoc",
link="https://godoc.org/gitlab.com/jhinrichsen/adventofcode2021"]
image:https://goreportcard.com/badge/gitlab.com/jhinrichsen/adventofcode2021["Go report
card", link="https://goreportcard.com/report/gitlab.com/jhinrichsen/adventofcode2021"]
image:https://gitlab.com/jhinrichsen/adventofcode2021/badges/main/pipeline.svg[link="https://gitlab.com/jhinrichsen/adventofcode2021/-/commits/main",title="pipeline status"]
image:https://gitlab.com/jhinrichsen/adventofcode2021/badges/main/coverage.svg[link="https://gitlab.com/jhinrichsen/adventofcode2021/-/commits/main",title="coverage report"]

= adventofcode2021

My take on https://adventofcode.com/2021/ in Go. As usual, i don't particularly
care if i provide my solutions _fast_, i try to be _correct_ on the first
answer, and care for being runtime efficient.
Most, if not all, puzzles are backed by unit testing the examples, and by some
benchmarks.

== Day 1

Part 1 Blattschuss.

Part 2 Blattschuss.

Nice and easy one. Parsing numbers happens so often i extended my helper file
`input.go` with an additional function that directly returns an array of
integers.

Benchmark:

----
go test -bench=. -run="" -benchmem
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay01Part2-8   	 1204111	      1033 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	gitlab.com/jhinrichsen/adventofcode2021	1.673s
----

To put 1.33 ns/op in perspective: without I/O, meaning excluding time for
reading puzzle input, the time it takes to solve part #1 is 1 μs.
Or, put the other way around, it solves part #1 one million times per second.

Go 1.17 introduces the use of register calling, but as most of my solutions are
in one function this is not a real difference to previous Go releases.

[source,go,linenums]
----
package adventofcode2021

func Day01Part1(ns []int) int {
	count := 0
	for i := 1; i < len(ns); i++ {
		if ns[i] > ns[i-1] {
			count++
		}
	}
	return count
}
----


[source,assembler]
----
"".Day01Part1 STEXT nosplit size=46 args=0x18 locals=0x0 funcid=0x0
	0x0000 00000 (day01.go:3)	TEXT	"".Day01Part1(SB), NOSPLIT|ABIInternal, $0-24
	0x0000 00000 (day01.go:3)	MOVQ	AX, "".ns+8(FP)
	0x0005 00005 (day01.go:3)	FUNCDATA	$0, gclocals·1a65e721a2ccc325b382662e7ffee780(SB)
	0x0005 00005 (day01.go:3)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x0005 00005 (day01.go:3)	FUNCDATA	$5, "".Day01Part1.arginfo1(SB)
	0x0005 00005 (day01.go:6)	MOVL	$1, CX            ; i := 1
	0x000a 00010 (day01.go:6)	XORL	DX, DX            ; count := 0
	0x000c 00012 (day01.go:5)	JMP	37
	0x000e 00014 (day01.go:6)	MOVQ	(AX)(CX*8), SI    ; ns[i] <1>
	0x0012 00018 (day01.go:6)	MOVQ	-8(AX)(CX*8), DI  ; ns[i-1] <1>
	0x0017 00023 (day01.go:7)	LEAQ	1(DX), R8
	0x001b 00027 (day01.go:6)	CMPQ	DI, SI
	0x001e 00030 (day01.go:7)	CMOVQLT	R8, DX
	0x0022 00034 (day01.go:5)	INCQ	CX                ; i++
	0x0025 00037 (day01.go:5)	CMPQ	BX, CX            ; len(ns) > i <2>
	0x0028 00040 (day01.go:5)	JGT	14
	0x002a 00042 (day01.go:10)	MOVQ	DX, AX            ; return count <3>
	0x002d 00045 (day01.go:10)	RET
----
<1> The index loop is easy enough for the compiler to reason it needs no bounds
checking, no panic()
<2> 3 words calling convention for slices: AX is pointer to
slice, BX is `len()`,
CX is `cap()`. `cap()` is not used in this function, so the compiler uses CX for
index `i`.
<3> return result via register, no stack cleanup required

== Day 2

Part 1 Blattschuss.

Part 2 Blattschuss.

No brainer. The only noticable piece is maybe the use of closures to avoid deep
structures surrounded by an `if/else`:

----
    if part1 {
        // 10 lines of complicated business logic
	// including more indent levels
    } else {
        // 15 lines of complicated business logic
	// including more indent levels
    }
----

can be replaced using closures (anonymous inner functions)

----
    if part1 {
        fn1()
    } else {
        fn2()
    }
----

which is easier on the eyes.

== Day 3

Part 1 Blattschuss.

Part 2 Blattschuss.

== Day 4

Part 1 Blattschuss.

Part2: one miss. My index was working when cutting input file into boards for
example input, but it was wrong and created 120 boards (the last 20 being empty)
instead of 100 boards when used on the read puzzle input for part 2.


Another gotcha: dynamically resizing a slice in a struct does not work, even
when passed via pointer receiver.

----
type S struct {
	A []int
}

func (a *S) add(i int) {
	a.A = append(a.A, i) // does not work
}
----

Benchmark for part 2:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay04Part2-8   	     687	   1852821 ns/op	  560245 B/op	    2846 allocs/op
----

1.8 ms, excluding I/O, including parsing.

== Day 5

Part 1 Blattschuss.

Part 2 Blattschuss.

Took me 30 min for part 1 and then another 60 min for part 2. The implementation
transparently handles both part 1 and part 2 using

----
diagonal := func(c1, c2 complex128) bool {
        return real(c1) != real(c2) && imag(c1) != imag(c2)
}
----

----
// for part 1, only consider horizontal or vertical lines
if part1 && diagonal(src, dst) {
        continue
}
----

Benchmark:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay05Part2-8   	      22	  46896856 ns/op	16126620 B/op	    7643 allocs/op
----

That is 46 ms for part 2, excluding I/O, including parsing, for 500 lines and a
total of 203660 coordinates, averaging to 230 ns per coordinate. 230*10^-9.

