image:https://godoc.org/gitlab.com/jhinrichsen/adventofcode2021?status.svg["godoc",
link="https://godoc.org/gitlab.com/jhinrichsen/adventofcode2021"]
image:https://goreportcard.com/badge/gitlab.com/jhinrichsen/adventofcode2021["Go report
card", link="https://goreportcard.com/report/gitlab.com/jhinrichsen/adventofcode2021"]
image:https://gitlab.com/jhinrichsen/adventofcode2021/badges/main/pipeline.svg[link="https://gitlab.com/jhinrichsen/adventofcode2021/-/commits/main",title="pipeline status"]
image:https://gitlab.com/jhinrichsen/adventofcode2021/badges/main/coverage.svg[link="https://gitlab.com/jhinrichsen/adventofcode2021/-/commits/main",title="coverage report"]

= Advent of Code 2021

[index]
== Index

My take on https://adventofcode.com/2021/ in Go. As usual, i don't particularly
care if i provide my solutions _fast_, i try to be _correct_ on the first
answer, and care for being runtime efficient.
Most, if not all, puzzles are backed by unit testing the examples, and by some
benchmarks.

Expected results are hard coded into the unit tests, so unless you are peeking
for a solution avoid looking at those.

----
      --------Part 1---------   --------Part 2---------
Day       Time    Rank  Score       Time    Rank  Score
  7   00:16:00    6872      0   00:23:18    5947      0
  6   00:22:46    7219      0   00:42:14    5105      0
  5   00:36:31    5008      0   01:30:41    7233      0
  4   13:46:10   40167      0   15:28:20   39605      0 <1>
  3       >24h   92810      0       >24h   70078      0
  2       >24h  118229      0       >24h  114094      0
  1       >24h  142010      0       >24h  128905      0
----
<1> I started on the weekend following Dec 1

== Day 1

Part 1 Blattschuss.

Part 2 Blattschuss.

Nice and easy one. Parsing numbers happens so often i extended my helper file
`input.go` with an additional function that directly returns an array of
integers.

Benchmark:

----
go test -bench=. -run="" -benchmem
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay01Part2-8   	 1204111	      1033 ns/op	       0 B/op	       0 allocs/op
PASS
ok  	gitlab.com/jhinrichsen/adventofcode2021	1.673s
----

To put 1.33 ns/op in perspective: without I/O, meaning excluding time for
reading puzzle input, the time it takes to solve part #1 is 1 μs.
Or, put the other way around, it solves part #1 one million times per second.

Go 1.17 introduces the use of register calling, but as most of my solutions are
in one function this is not a real difference to previous Go releases.

[source,go,linenums]
----
package adventofcode2021

func Day01Part1(ns []int) int {
	count := 0
	for i := 1; i < len(ns); i++ {
		if ns[i] > ns[i-1] {
			count++
		}
	}
	return count
}
----

Let's double check how this transfers to assembler.
Remember Go has its own assembler opcodes.
Even if you can recite chapter 'Conditional Jump' on page 64 of
https://www.amd.com/system/files/TechDocs/24592.pdf[AMD64 Reference] woken up at
3:30am in the middle of the night completely drunk, you will not find JLS.
For the time being, one needs to refer to Go internal source code to find the
mappings for
https://go.googlesource.com/go/+/master/src/cmd/asm/internal/arch/arch.go#145[
JLS]:

[source,go]
----
	instructions["JLS"] = x86.AJLS  /* lower or same (unsigned) (CF = 1 || ZF = 1) */
----

The https://go.dev/doc/asm[Quick Guide to Go's assembler] is a useful read to
understand this snippet.

[source,assembler]
----
"".Day01Part1 STEXT nosplit size=46 args=0x18 locals=0x0 funcid=0x0
	0x0000 00000 (day01.go:3)	TEXT	"".Day01Part1(SB), NOSPLIT|ABIInternal, $0-24
	0x0000 00000 (day01.go:3)	MOVQ	AX, "".ns+8(FP)
	0x0005 00005 (day01.go:3)	FUNCDATA	$0, gclocals·1a65e721a2ccc325b382662e7ffee780(SB)
	0x0005 00005 (day01.go:3)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x0005 00005 (day01.go:3)	FUNCDATA	$5, "".Day01Part1.arginfo1(SB)
	0x0005 00005 (day01.go:6)	MOVL	$1, CX            ; i := 1
	0x000a 00010 (day01.go:6)	XORL	DX, DX            ; count := 0
	0x000c 00012 (day01.go:5)	JMP	37
	0x000e 00014 (day01.go:6)	MOVQ	(AX)(CX*8), SI    ; ns[i] <1>
	0x0012 00018 (day01.go:6)	MOVQ	-8(AX)(CX*8), DI  ; ns[i-1] <1>
	0x0017 00023 (day01.go:7)	LEAQ	1(DX), R8
	0x001b 00027 (day01.go:6)	CMPQ	DI, SI
	0x001e 00030 (day01.go:7)	CMOVQLT	R8, DX
	0x0022 00034 (day01.go:5)	INCQ	CX                ; i++
	0x0025 00037 (day01.go:5)	CMPQ	BX, CX            ; len(ns) > i <2>
	0x0028 00040 (day01.go:5)	JGT	14
	0x002a 00042 (day01.go:10)	MOVQ	DX, AX            ; return count <3>
	0x002d 00045 (day01.go:10)	RET
----
<1> The index loop is easy enough for the compiler to reason it needs no bounds
checking, no panic()
<2> 3 words calling convention for slices: AX is pointer to
slice, BX is `len()`,
CX is `cap()`. `cap()` is not used in this function, so the compiler uses CX for
index `i`.
<3> return result via register, no stack cleanup required

== Day 2

Part 1 Blattschuss.

Part 2 Blattschuss.

No brainer. The only noticable piece is maybe the use of closures to avoid deep
structures surrounded by an `if/else`:

----
    if part1 {
        // 10 lines of complicated business logic
	// including more indent levels
    } else {
        // 15 lines of complicated business logic
	// including more indent levels
    }
----

can be replaced using closures (anonymous inner functions)

----
    if part1 {
        fn1()
    } else {
        fn2()
    }
----

which is easier on the eyes.

== Day 3

Part 1 Blattschuss.

Part 2 Blattschuss.

== Day 4

Part 1 Blattschuss.

Part2: one miss. My index was working when cutting input file into boards for
example input, but it was wrong and created 120 boards (the last 20 being empty)
instead of 100 boards when used on the read puzzle input for part 2.


Another gotcha: dynamically resizing a slice in a struct does not work, even
when passed via pointer receiver.

----
type S struct {
	A []int
}

func (a *S) add(i int) {
	a.A = append(a.A, i) // does not work
}
----

Benchmark for part 2:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay04Part2-8   	     687	   1852821 ns/op	  560245 B/op	    2846 allocs/op
----

1.8 ms, excluding I/O, including parsing.

== Day 5

Part 1 Blattschuss.

Part 2 Blattschuss.

Took me 30 min for part 1 and then another 60 min for part 2. The implementation
transparently handles both part 1 and part 2 using

----
diagonal := func(c1, c2 complex128) bool {
        return real(c1) != real(c2) && imag(c1) != imag(c2)
}
----

----
// for part 1, only consider horizontal or vertical lines
if part1 && diagonal(src, dst) {
        continue
}
----

Benchmark:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay05Part2-8   	      22	  46896856 ns/op	16126620 B/op	    7643 allocs/op
----

That is 46 ms for part 2, excluding I/O, including parsing, for 500 lines and a
total of 203660 coordinates, averaging to 230 ns per coordinate. 230*10^-9.

Using integer based arithmetic instead of complex numbers is a little bit
faster, it completes at 87% of the time the complex implementation requires.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay05Part2-8   	      26	  40890804 ns/op	16117340 B/op	    7627 allocs/op
----

== Day 6

Part 1 Blattschuss

Part 2 Blattschuss

Part 2 blows my machine around day 240/245 of 256 days when using the naive
approach of counting each lanternfish separate.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay06Part2-8   	   60168	     19808 ns/op	    5880 B/op	       8 allocs/op
----

20 μs, this time including I/O and parsing, or 50_000 solutions per second.

There is one superfluous bound check at runtime, an array of lines is passed
although we only expect one single line of comma separated values:

[source,go]
----
21 func Day06(lines []string, days int) (uint, error) {
22         fishes, err := ParseCommaSeparatedNumbers(lines[0]) <1>
----
<1> directly accessing line #0 requires bounds checking

----
"".Day06 STEXT size=350 args=0x20 locals=0x60 funcid=0x0
	0x0000 00000 (day06.go:21)	TEXT	"".Day06(SB), ABIInternal, $96-32
	0x0000 00000 (day06.go:21)	CMPQ	SP, 16(R14)
	0x0004 00004 (day06.go:21)	PCDATA	$0, $-2
	0x0004 00004 (day06.go:21)	JLS	296
	0x000a 00010 (day06.go:21)	PCDATA	$0, $-1
	0x000a 00010 (day06.go:21)	SUBQ	$96, SP
	0x000e 00014 (day06.go:21)	MOVQ	BP, 88(SP)
	0x0013 00019 (day06.go:21)	LEAQ	88(SP), BP
	0x0018 00024 (day06.go:21)	MOVQ	AX, "".lines+104(FP)
	0x001d 00029 (day06.go:21)	FUNCDATA	$0, gclocals·1a65e721a2ccc325b382662e7ffee780(SB)
	0x001d 00029 (day06.go:21)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
	0x001d 00029 (day06.go:21)	FUNCDATA	$5, "".Day06.arginfo1(SB)
	0x001d 00029 (day06.go:21)	NOP
	0x0020 00032 (day06.go:22)	TESTQ	BX, BX <1>
	0x0023 00035 (day06.go:22)	JLS	285 <2>


	0x011d 00285 (day06.go:22)	XORL	AX, AX
	0x011f 00287 (day06.go:22)	MOVQ	BX, CX
	0x0122 00290 (day06.go:22)	CALL	runtime.panicIndex(SB)
----
<1> lines passed via AX, len(lines) passed via BX
<2> JLS translates to JBE, 'Jump if below or equal' (BX <= 0)

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay06Part2-8   	   60613	     19137 ns/op	    7552 B/op	       2 allocs/op
----

If we expect exactly one line, it should be part of the function's signature.
This is not a premature optimization, it is part of the contract.

In addition, if the algorithm requires a list of numbers, it should be stated
so. Parsing from a comma separated list of string values is duty of the caller.
Of course we provide `ParseCommaSeparatedNumbers()` for this exact use case.

[source,go]
----
----

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay06Part2-8   	 1006672	      1076 ns/op	       0 B/op	       0 allocs/op
----

So instead of 20 μs, we are down to 1 μs, and reduced 8 allocations to 0.

Ready for some ARM Opcodes? Let's Go...

.Disassembler listing
|===
| Assembler | Go

a|
----
0x0000 00000 (day06.go:21)	TEXT	"".Day06(SB), ABIInternal, $112-56
0x0000 00000 (day06.go:21)	MOVD	16(g), R1
0x0004 00004 (day06.go:21)	PCDATA	$0, $-2
0x0004 00004 (day06.go:21)	MOVD	RSP, R2
0x0008 00008 (day06.go:21)	CMP	R1, R2
0x000c 00012 (day06.go:21)	BLS	268
0x0010 00016 (day06.go:21)	PCDATA	$0, $-1
0x0010 00016 (day06.go:21)	MOVD.W	R30, -112(RSP)
0x0014 00020 (day06.go:21)	MOVD	R29, -8(RSP)
0x0018 00024 (day06.go:21)	SUB	$8, RSP, R29
0x001c 00028 (day06.go:21)	FUNCDATA	ZR, gclocals·564c88c798e834d77927d2fafb0b5dca(SB)
0x001c 00028 (day06.go:21)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
0x001c 00028 (day06.go:21)	FUNCDATA	$5, "".Day06.arginfo1(SB)
----

a|
----
func Day06(fishes []int, days int) (uint, error) {
----
a|
----
0x001c 00028 (day06.go:23)	STP	(ZR, ZR), "".ages-72(SP)
0x0020 00032 (day06.go:23)	STP	(ZR, ZR), "".ages-56(SP)
0x0024 00036 (day06.go:23)	STP	(ZR, ZR), "".ages-40(SP)
0x0028 00040 (day06.go:23)	STP	(ZR, ZR), "".ages-24(SP)
0x002c 00044 (day06.go:23)	MOVD	ZR, "".ages-8(SP)
----

a|
----
var ages [groups]uint
----
a|
----
0x0030 00048 (day06.go:24)	MOVD	"".fishes+8(FP), R2
0x0034 00052 (day06.go:24)	MOVD	"".fishes(FP), R3
0x0038 00056 (day06.go:24)	MOVD	ZR, R0
0x003c 00060 (day06.go:24)	JMP	84
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x0040 00064 (day06.go:25)	MOVD	$"".ages-72(SP), R5
0x0044 00068 (day06.go:25)	MOVD	(R5)(R4<<3), R6
0x0048 00072 (day06.go:25)	ADD	$1, R6, R6
0x004c 00076 (day06.go:25)	MOVD	R6, (R5)(R4<<3)
----

a|
----
ages[fishes[i]]++
----
a|
----
0x0050 00080 (day06.go:24)	ADD	$1, R0, R0
0x0054 00084 (day06.go:24)	CMP	R0, R2
0x0058 00088 (day06.go:24)	BLE	108
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x005c 00092 (day06.go:25)	MOVD	(R3)(R0<<3), R4
0x0060 00096 (day06.go:25)	CMP	$9, R4
0x0064 00100 (day06.go:25)	BLO	64
0x0068 00104 (day06.go:25)	JMP	252
----

a|
----
ages[fishes[i]]++
----
a|
----
0x006c 00108 (day06.go:24)	MOVD	"".days+24(FP), R0
0x0070 00112 (day06.go:24)	MOVD	ZR, R1
0x0074 00116 (day06.go:24)	JMP	140
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x0078 00120 (day06.go:33)	MOVD	"".ages-24(SP), R3
0x007c 00124 (day06.go:33)	ADD	R2, R3, R3
0x0080 00128 (day06.go:33)	MOVD	R3, "".ages-24(SP)
----

a|
----
ages[6] += babies
----
a|
----
0x0084 00132 (day06.go:34)	MOVD	R2, "".ages-8(SP)
----

a|
----
ages[8] = babies
----
a|
----
0x0088 00136 (day06.go:28)	ADD	$1, R1, R1
0x008c 00140 (day06.go:28)	CMP	R1, R0
0x0090 00144 (day06.go:28)	BLE	160
----

a|
----
for day := 0; day < days; day++ {
----
a|
----
0x0094 00148 (day06.go:29)	MOVD	"".ages-72(SP), R2
0x0098 00152 (day06.go:29)	MOVD	ZR, R3
----

a|
----
babies := ages[0]
----
a|
----
0x009c 00156 (day06.go:30)	JMP	240
0x00a0 00160 (day06.go:30)	MOVD	ZR, R0
0x00a4 00164 (day06.go:30)	MOVD	ZR, R1
----

a|
----
for age := 0; age < groups-1; age++ {
----
a|
----
0x00a8 00168 (day06.go:28)	JMP	192
----

a|
----
for day := 0; day < days; day++ {
----
a|
----
0x00ac 00172 (day06.go:38)	ADD	$1, R0, R2
----

a|
----
for i := range ages {
----
a|
----
0x00b0 00176 (day06.go:39)	MOVD	$"".ages-72(SP), R3
0x00b4 00180 (day06.go:39)	MOVD	(R3)(R0<<3), R3
0x00b8 00184 (day06.go:39)	ADD	R3, R1, R1
----

a|
----
sum += ages[i]
----
a|
----
0x00bc 00188 (day06.go:38)	MOVD	R2, R0
0x00c0 00192 (day06.go:38)	CMP	$9, R0
0x00c4 00196 (day06.go:38)	BLT	172
----

a|
----
for i := range ages {
----
a|
----
0x00c8 00200 (day06.go:41)	MOVD	R1, "".~r2+32(FP)
0x00cc 00204 (day06.go:41)	STP	(ZR, ZR), "".~r3+40(FP)
0x00d0 00208 (day06.go:41)	MOVD	-8(RSP), R29
0x00d4 00212 (day06.go:41)	MOVD.P	112(RSP), R30
0x00d8 00216 (day06.go:41)	RET	(R30)
----

a|
----
return sum, nil
----
a|
----
0x00dc 00220 (day06.go:31)	ADD	$1, R3, R4
0x00e0 00224 (day06.go:31)	MOVD	$"".ages-72(SP), R5
0x00e4 00228 (day06.go:31)	MOVD	(R5)(R4<<3), R6
0x00e8 00232 (day06.go:31)	MOVD	R6, (R5)(R3<<3)
----

a|
----
ages[age] = ages[age+1]
----
a|
----
0x00ec 00236 (day06.go:30)	MOVD	R4, R3
0x00f0 00240 (day06.go:30)	CMP	$8, R3
0x00f4 00244 (day06.go:30)	BLT	220
0x00f8 00248 (day06.go:30)	JMP	120
----

a|
----
for age := 0; age < groups-1; age++ {
----
a|
----
0x00fc 00252 (day06.go:25)	MOVD	R4, R0
0x0100 00256 (day06.go:25)	MOVD	$9, R1
0x0104 00260 (day06.go:25)	PCDATA	$1, $1
0x0104 00260 (day06.go:25)	CALL	runtime.panicIndex(SB) <1>
0x0108 00264 (day06.go:25)	HINT	ZR
0x010c 00268 (day06.go:25)	NOP
----

a|
----
ages[fishes[i]]++
----
a|
----
0x010c 00268 (day06.go:21)	PCDATA	$1, $-1
0x010c 00268 (day06.go:21)	PCDATA	$0, $-2
0x010c 00268 (day06.go:21)	MOVD	R30, R3
0x0110 00272 (day06.go:21)	CALL	runtime.morestack_noctxt(SB)
0x0114 00276 (day06.go:21)	PCDATA	$0, $-1
0x0114 00276 (day06.go:21)	JMP	0
----

a|
----
func Day06(fishes []int, days int) (uint, error) {
----

|===
<1> No more bound checking on input

There is one more bound check in

    ages[fishes[i]]++

We are using the input itself to index into the `ages` array, which the compiler
obviously cannot verify.

Verification:

[source,go]
----
21 func Day06(fishes []int, days int) (uint, error) {
22         const groups = 8
23         var ages [groups + 1]uint // 0..7 plus babies in 8
24         for i := 0; i < len(fishes); i++ {
25                 ages[fishes[i]]++
26         }
----

Now, there's a shortcut for checking for bound checking.
Instead of looking at the disassembly, one can

----
go build -gcflags="-d=ssa/check_bce/debug=1" day06.go
./day06.go:25:7: Found IsInBounds
----

The message is a bit misleading for my taste, what the compiler is telling us is
that line #25 requires bound checking.

What if we provide some more information about our `fishes` universe?
We expect ages from 0..7, so what if we hint `ages[fishes[i] % groups]`?

[source,go]
----
21 func Day06(fishes []int, days int) (uint, error) {
22         const groups = 8
23         var ages [groups + 1]uint // 0..7 plus babies in 8
24         for i := 0; i < len(fishes); i++ {
25                 ages[fishes[i]%groups]++
26         }
----

----
go build -gcflags="-d=ssa/check_bce/debug=1" day06.go
./day06.go:25:7: Found IsInBounds
----

Nearly there, but still checking.
x % 8 does not necessarily result in `0..7`.
If x is of type `int`, it can be negative, and `-3 % 8 = -3`, so the compiler is
right to keep checking.
One more try, this time using `uint` instead of `int` fishes:

----
 21 func Day06(fishes []uint, days uint) (uint, error) {
 22         const groups = 8
 23         var ages [groups + 1]uint // 0..7 plus babies in 8
 24         for i := 0; i < len(fishes); i++ {
 25                 ages[fishes[i]%groups]++
 26         }
----

Great, no more bound checking.

.Disassembler listing
|===
| Assembler | Go

a|
----
0x0000 00000 (day06.go:21)	TEXT	"".Day06(SB), NOSPLIT|LEAF|ABIInternal, $96-56
0x0000 00000 (day06.go:21)	MOVD.W	R30, -96(RSP)
0x0004 00004 (day06.go:21)	MOVD	R29, -8(RSP)
0x0008 00008 (day06.go:21)	SUB	$8, RSP, R29
0x000c 00012 (day06.go:21)	FUNCDATA	ZR, gclocals·564c88c798e834d77927d2fafb0b5dca(SB)
0x000c 00012 (day06.go:21)	FUNCDATA	$1, gclocals·69c1753bd5f81501d95132d08af04464(SB)
0x000c 00012 (day06.go:21)	FUNCDATA	$5, "".Day06.arginfo1(SB)
----

a|
----
func Day06(fishes []uint, days uint) (uint, error) {
----
a|
----
0x000c 00012 (day06.go:23)	STP	(ZR, ZR), "".ages-72(SP)
0x0010 00016 (day06.go:23)	STP	(ZR, ZR), "".ages-56(SP)
0x0014 00020 (day06.go:23)	STP	(ZR, ZR), "".ages-40(SP)
0x0018 00024 (day06.go:23)	STP	(ZR, ZR), "".ages-24(SP)
0x001c 00028 (day06.go:23)	MOVD	ZR, "".ages-8(SP)
----

a|
----
var ages [groups + 1]uint // 0..7 plus babies in 8
----
a|
----
0x0020 00032 (day06.go:24)	MOVD	"".fishes+8(FP), R0
0x0024 00036 (day06.go:24)	MOVD	"".fishes(FP), R1
0x0028 00040 (day06.go:24)	MOVD	ZR, R2
0x002c 00044 (day06.go:24)	JMP	76
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x0030 00048 (day06.go:25)	MOVD	(R1)(R2<<3), R3
0x0034 00052 (day06.go:25)	UBFIZ	$3, R3, $3, R3
0x0038 00056 (day06.go:25)	MOVD	$"".ages-72(SP), R4
0x003c 00060 (day06.go:25)	MOVD	(R4)(R3), R5
0x0040 00064 (day06.go:25)	ADD	$1, R5, R5
0x0044 00068 (day06.go:25)	MOVD	R5, (R4)(R3)
----

a|
----
ages[fishes[i]%groups]++
----
a|
----
0x0048 00072 (day06.go:24)	ADD	$1, R2, R2
0x004c 00076 (day06.go:24)	CMP	R2, R0
0x0050 00080 (day06.go:24)	BGT	48
0x0054 00084 (day06.go:24)	MOVD	"".days+24(FP), R0
0x0058 00088 (day06.go:24)	MOVD	ZR, R1
0x005c 00092 (day06.go:24)	JMP	116
----

a|
----
for i := 0; i < len(fishes); i++ {
----
a|
----
0x0060 00096 (day06.go:33)	MOVD	"".ages-24(SP), R3
0x0064 00100 (day06.go:33)	ADD	R2, R3, R3
0x0068 00104 (day06.go:33)	MOVD	R3, "".ages-24(SP)
----

a|
----
ages[6] += babies
----
a|
----
0x006c 00108 (day06.go:34)	MOVD	R2, "".ages-8(SP)
----

a|
----
ages[8] = babies
----
a|
----
0x0070 00112 (day06.go:28)	ADD	$1, R1, R1
0x0074 00116 (day06.go:28)	CMP	R1, R0
0x0078 00120 (day06.go:28)	BLS	136
----

a|
----
for day := uint(0); day < days; day++ {
----
a|
----
0x007c 00124 (day06.go:29)	MOVD	"".ages-72(SP), R2
0x0080 00128 (day06.go:29)	MOVD	ZR, R3
----

a|
----
babies := ages[0]
----
a|
----
0x0084 00132 (day06.go:30)	JMP	216
0x0088 00136 (day06.go:30)	MOVD	ZR, R0
0x008c 00140 (day06.go:30)	MOVD	ZR, R1
----

a|
----
for age := 0; age < groups; age++ {
----
a|
----
0x0090 00144 (day06.go:28)	JMP	168
----

a|
----
for day := uint(0); day < days; day++ {
----
a|
----
0x0094 00148 (day06.go:38)	ADD	$1, R0, R2
----

a|
----
for i := range ages {
----
a|
----
0x0098 00152 (day06.go:39)	MOVD	$"".ages-72(SP), R3
0x009c 00156 (day06.go:39)	MOVD	(R3)(R0<<3), R3
0x00a0 00160 (day06.go:39)	ADD	R3, R1, R1
----

a|
----
sum += ages[i]
----
a|
----
0x00a4 00164 (day06.go:38)	MOVD	R2, R0
0x00a8 00168 (day06.go:38)	CMP	$9, R0
0x00ac 00172 (day06.go:38)	BLT	148
----

a|
----
for i := range ages {
----
a|
----
0x00b0 00176 (day06.go:41)	MOVD	R1, "".~r2+32(FP)
0x00b4 00180 (day06.go:41)	STP	(ZR, ZR), "".~r3+40(FP)
0x00b8 00184 (day06.go:41)	ADD	$96, RSP
0x00bc 00188 (day06.go:41)	SUB	$8, RSP, R29
0x00c0 00192 (day06.go:41)	RET	(R30)
----

a|
----
return sum, nil
----
a|
----
0x00c4 00196 (day06.go:31)	ADD	$1, R3, R4
0x00c8 00200 (day06.go:31)	MOVD	$"".ages-72(SP), R5
0x00cc 00204 (day06.go:31)	MOVD	(R5)(R4<<3), R6
0x00d0 00208 (day06.go:31)	MOVD	R6, (R5)(R3<<3)
----

a|
----
ages[age] = ages[age+1]
----
a|
----
0x00d4 00212 (day06.go:30)	MOVD	R4, R3
0x00d8 00216 (day06.go:30)	CMP	$8, R3
0x00dc 00220 (day06.go:30)	BLT	196
0x00e0 00224 (day06.go:30)	JMP	96
----

a|
----
for age := 0; age < groups; age++ {
----

|===



== Day 7

Part 1 Blattschuss

Part 2 Blattschuss.

Easiest puzzle so far, took me 23 min for both parts.
Everybody and their mother was fast on this one, so we broke the private
leaderboard :-).

Mysteriously, i had no off-by-one in this puzzle, and avoided my typical
mistakes:

----
	burn := func(dist int) int {
		if part1 {
			return dist
		}
		// OEIS A000217 triangular number
		return dist * (dist + 1) / 2 <1>
	}

	fuel := func(pos int) int {
		sum := 0
		for i := range positions {
			dist := positions[i] - pos
			if dist < 0 {
				dist = -dist <2>
			}
			sum += burn(dist)
		}
		return sum
	}

	fmin := math.MaxInt32 <3>
	for pos := min; pos <= max; pos++ { <4>
		f := fuel(pos)
		if f < fmin {
			fmin = f
		}
	}
----
<1> OEIS contains thousands of man-years of the smartest brains on this planet
ever
<2> A distance can never be negative
<3> Do not initialize min values to 0
<4> Control end of interval (pos < max versus pos <= max)

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2021
cpu: AMD Ryzen 5 3400G with Radeon Vega Graphics
BenchmarkDay07Part2-8   	     260	   4508358 ns/op	       0 B/op	       0 allocs/op
----

4.5 ms, no allocations.
